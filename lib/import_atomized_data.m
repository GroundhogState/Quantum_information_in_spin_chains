function import_data = import_atomized_data(config)
% A wrapper for get_network_data
%   TODO: Safety checks

datapath = config.gen.savepath;
subdirs = dir(fullfile(config.gen.savepath,'W=*'));
num_dirs = numel(subdirs);
import_data.W = cell(num_dirs,1);
import_data.net_data = cell(num_dirs,1);
for dir_idx = 1:num_dirs
    subdir = subdirs(dir_idx).name;
    files = dir(fullfile(datapath,subdir,'*.mat'));
    num_files = size(files,1);
    dir_data = cell(numel(subdir,1));    
    fprintf('\n Importing %6.f files from dir %u/%u:\n000000',num_files,dir_idx,num_dirs)
    for N=1:num_files
        if mod(N,100) ==0
            fprintf('\b\b\b\b\b\b%06.f',N)
        end
        fname = files(N).name;
        fname = fullfile(datapath,subdir,fname);
        data = load(fname);
        dir_data{N} = get_atomized_data(data);
    end % loop over files
    import_data.W{dir_idx} = str2double(subdir(3:end));
    import_data.net_data{dir_idx} = dir_data; 
end % loop over dirs

end

function network_data = get_atomized_data(data)

% This function is a part-B to the gen_data function, designed to be a bit
% more flexible. The objects here could *probably* be ported to be
% constructed in individual analyses, which might actually enhance
% modularity. That'll be left for later - the vis/anal parts will act on
% these, to save the expense of repeatedly computing them whenever later
% functions called. Of course, caching large calls is an option.

%Accepts ONE input data.mat file (single disorder strength) and returns a struct network_data
% Input field for each cell in data.samp{}
%       L               Spin chain length
%       W               Disorder bandwidth
%       num_eigs        Number of selected eigenvalues
%       sel             Indices of selected eigen*
%       num_samples     Number of disorder realizations
%       nrg             List of selected RESCALED eigenvalues corresponding to
%       v_sel           List of selected eigenvalues which are turned into
%       A_list          State graph objects generated by vec_to_graph
% Output: 
%   struct network_data with fields defined below, indexed by {realization#, eigenvalue}
 
    % Importing parameters
    network_data.prm.L = data.L;
    network_data.prm.W = data.W;
    
%     % Setting up output
%     % Laplacian properties
%     network_data.L.Laplacian = zeros(data.L,data.L);
%     network_data.L.evals = zeros(data.L);
%     network_data.L.evecs = zeros(data.L,data.L);
%     network_data.L.trace = [];
%    
%     % Aleph properties
%     network_data.A.Aleph = zeros(data.L,data.L);
%     network_data.A.evals = zeros(data.L);
%     network_data.A.evecs = zeros(data.L,data.L);
%     network_data.A.trace = [];
% %     network_data.
%     
%     % Graph properties
%     network_data.G.degree_list = zeros(data.L);
%     network_data.G.weight_list = zeros(data.L*(data.L-1)/2);
%     network_data.G.node_centrality = zeros(data.L);
%     
%     % Physical properties
%     network_data.P.entropy_VN=zeros(data.L);
%     network_data.P.nrg = [];

    
%         nrg_full=data.nrg;
        network_data.P.nrg = data.nrg;
            % Aleph properties
            Aleph_UD = data.A;
            % Produces Aleph with -2*onsite entropy along diagonal
            Aleph = Aleph_UD + Aleph_UD - 3*diag(diag(Aleph_UD));
            
            network_data.A.Aleph = Aleph;                               
            [network_data.A.evecs,val_temp] = eigs(Aleph,data.L);
            network_data.A.evals = diag(val_temp);
            network_data.A.trace = trace(Aleph); % = 2* total onsite entropy

            % Generate additional properties
            A_temp = Aleph - diag(diag(Aleph));
            D_temp = sum(A_temp)';  
            mask = triu(ones(network_data.prm.L),1)==1;
            weight_all = A_temp(mask);
            mu_temp =A_temp*D_temp./D_temp; % Weighted sum of (normalized) neighbour degrees
            norm = zeros(data.L,1);
            for i=1:data.L
                norm(i) = sum(D_temp) - D_temp(i); %Average of neighbour degrees
            end

            % Laplacian properties
            network_data.L.Laplacian = -(A_temp - diag(D_temp));    
            [network_data.L.evecs,v_temp] = eigs(network_data.L.Laplacian,data.L);
            network_data.L.evals = diag(v_temp);
            network_data.L.trace = trace(squeeze(network_data.L.Laplacian));

            % Graph properties
            network_data.G.degree_list = D_temp;
            network_data.G.weight_list = weight_all;
            network_data.G.node_centrality = norm.*mu_temp; %= sum(deg_i w_ij) / avg(d_j) for all i in Neighb(j)

            % Physical properties
            network_data.P.entropy_VN = 0.5*diag(Aleph);
            network_data.P.TMI = sum(sum(Aleph));

%         end % Loop over eigenvectors
%     end% Loop over samples
    
end